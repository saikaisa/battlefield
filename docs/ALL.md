# 数据结构

## 六角格

六角格是整个地图的基本单元，是承载地形、实体部署、状态变化与交互操作的最小空间单位。地图中的每一个区域都以六角格为单位进行组织，一切渲染、控制、判断与交互都在六角格粒度上执行。

六角格是整个地图的基本单元，承载地形、实体部署、状态变化与交互操作。地图中的每个区域均以六角形划分，在 Cesium 渲染场景中，六角格的位置将以经纬度和高度形式进行描述，并通过 `Cesium.Cartesian3.fromDegrees(longitude, latitude, height)` 转换为三维笛卡尔坐标。其他属性与原设计保持一致，用于地形效果、交互高亮、控制权状态以及资源扩展。

### 属性解释

#### 1. 基础标识属性（Identification）

- **六角格编号 (`hex_id`)**
  - 全局唯一的标识，用于逻辑引用、数据库索引与前端显示。
- **空间位置 (`position`)**
  - 描述六角格在地球表面的实际位置，符合 Cesium 坐标要求，包含：
    - **points**：点数据（1 个中心点和 6 个顶点）
      - **longitude**：经度（单位：度）
      - **latitude**：纬度（单位：度）
      - **height**：相对于 WGS84 椭球的高度（单位：米），此值通过 `Cesium.Cartesian3.fromDegrees` 转换为 3D 坐标
    - **row/col**：表示该六角格在逻辑网格中的行号和列号，用于内部寻路与定位

#### 2. 地形属性（Terrain Attributes）

- **主地形类型 (`terrain_type`)**

  - 表示该六角格内占比最大的地形种类，如 `plain`（平原）、`mountain`（山地）、`urban`（城市）、`water`（水域）、`forest`（森林）、`desert`（沙漠）。该属性决定默认的行动力消耗和战斗修正。
  
- **高度 (`elevation`)**

  - 通过采样该格内多个点进行加权平均计算得到的代表性高度值，用于影响模型渲染和战斗判断，可与 `position.height` 相近。
  
- **可通行性 (`passability`)**

  - 一个对象，表示该六角格对不同军种的通行状况，例如：

    ```json
    {
      "land": true,
      "naval": false,
      "air": true
    }
    ```
  - 例如，悬崖对陆军不可通行、乱石滩对海军不可通行，而空军始终可通行。

#### 3. 战场状态属性（Battlefield State）

- **部队列表 (`forces_ids`)**：通过特殊组件映射而不是其属性
  - 当前驻扎或经过该六角格的部队引用列表，用于前端显示和交战判断；规则由后端控制。
- **隶属方 (`control_faction`)**
  - 当前该六角格的控制权归属，初始默认为 `"neutral"`，后续可更新为 `"blue"` 或 `"red"`。

#### 4. 渲染状态（Visibility）

注意：战争迷雾与六角格标记是分开的，战争迷雾和六角格标记不在同一图层。

- **六角格标记状态 (`visual_styles`)：仅前端存在的属性！它是一个列表，会有多个 `visual_style` 子属性**

  - 定义六角格的各种不同样式的标记和高亮，包括但不限于：
    - 默认状态样式（中立或不在视野范围内的默认样式）：涉及 `visible_to`、`control_faction`
    - 地形边框（切换到地形图层时才会显示）：涉及 `terrain_type`
    - 六角格选中高亮（正常图层下选中六角格时的效果）：涉及**前端模块**的 `selected_hex_list`
    - 敌我阵营标记样式（正常图层下区分敌我六角格的标记）：涉及 `control_faction`
    - 移动相关：路径选中高亮（比如可行段和行动力不足/不合法段应用不同颜色区分）
    - 进攻相关：指挥范围高亮、可进攻敌方六角格高亮
- **可见性状态 (`visible_to`)**

  - 定义该六角格对于不同阵营是否可见，例如：

    ```json
    {
      "blue": true,
      "red": false
    }
    ```
  - 帮助前端实现战争迷雾效果，决定是否展示单位和细节。

#### 5. 附加信息（Additional Info）

- **是否为关键点 (`is_objective_point`)**（暂未使用）
  - 指示该格是否属于战斗关键节点（如城市、桥梁等）。
- **资源属性 (`resource`)**（暂未使用）
  - 若涉及战略资源管理，可记录补给、油料、医疗等资源信息。

### 数据结构

```json
{
  "hex_id": "H0001",
  "position": {
    "longitude": 116.407394,
    "latitude": 39.904211,
    "height": 50,
    "row": 10,
    "col": 5
  },
  "terrain_attributes": {
    "terrain_type": "plain",
    "elevation": 50,
    "passability": {
      "land": true,
      "naval": false,
      "air": true
    }
  },
  "battlefield_state": {
    "forces_list": [],
    "control_faction": "neutral"
  },
  "visibility": {
    "visual_styles": [
       {
         ...
       },
       {
         ...
       }
    ],
    "visible_to": {
      "blue": true,
      "red": false
    }
  },
  "additional_info": {
    "is_objective_point": false,
    "resource": null
  }
}
```

## 兵种系统

### (1a) 兵种：属性解释

兵种（Unit）是军事仿真系统中最基本的单位类型，定义了某类军事单位的通用属性，所有具体的部队或战斗群都是基于兵种组合而成的。

兵种的属性一般分为以下几个大类，每个大类下详细说明具体属性：

#### 1. 基础标识属性（Identification）

- **兵种ID (`unit_id`)**：唯一标识该兵种，用于数据库、API调用和规则匹配等。
- **兵种名称 (`unit_name`)**：用于前端界面显示的名称，如“步兵”、“炮兵”、“坦克”等。
- **兵种军种 (`service`)**：描述兵种的军种，有海军、陆军、空军三大军种，但一个兵种也可以同时是陆军和海军。
- **兵种类别 (`category`)**：描述兵种的大类，如步兵、炮兵、装甲部队等。
- **可用阵营 (`unit_availability`)**：用来描述该兵种在哪些阵营可用，如“蓝方”。它可以同时在多个阵营可用，是一个存储阵营名的列表。

#### 2. 战斗属性（Combat Attributes）

**① 攻击力（`attack_power`）：兵种的攻击效能。**

- **基础攻击力 (`base_attack_power`)**：兵种原始、不受外界影响的默认攻击数值，作为计算基数。
- **海陆空系数 (`domain_factor`)**：描述兵种在面对不同目标类型（海、陆、空）时的攻击修正比例。
  - 对地加成（`land`）
  - 对海加成（`sea`）
  - 对空加成（`air`）
- **地形因素系数 (`terrain_factor`)**：描述兵种在特定地形环境下的攻击修正比例。
  - 平原（`plain`）
  - 丘陵（`hill`）
  - 山地（`mountain`）
  - 水域（`water`）

**② 防御力（`defense_power`）：兵种的防御效能。**

细分同上。

#### 3.  生存属性（Survival Attributes）

**① 可视范围 (`visibility_radius`)**

描述包含该兵种的部队的最大可视范围。例如侦查类兵种的可视范围会比普通兵种大。

**② 行动力消耗速率 (`action_point_cost`)**

描述单位通过不同地形时每次移动所消耗的行动力，可能因兵种和地形不同而异。

- **基础行动力消耗速率 (`base_action_point_cost`)**：兵种原始、不受地形影响的默认行动力消耗速率，作为计算基数。
- **地形因素系数 (`terrain_factor`)**：描述兵种在特定地形环境下的行动力消耗率修正比例。

  - 平原（`plain`）
  - 丘陵（`hill`）
  - 山地（`mountain`）
  - 水域（`water`）

  > 一个部队的最大行动力为 100，部队的行动力消耗速率为组成其的兵种中行动力消耗速率最大的那个，所以兵种的行动力消耗速率在某地形若大于 100，就意味着该地形不可通过。
  >
  > 例如：陆军在水域的地形因素系数应足够大（如 10000），这样最终的行动力消耗速率必大于 100，这意味着该兵种不能跨过水域。
  >

**③ 恢复能力（`recovery_rate`）**

描述兵种为整个部队兵力进行恢复的能力，它影响兵力值回复速率。无补给能力的兵种该项始终为 0（如普通步兵），有补给能力的兵种该项为正数（如医疗兵+10）。

#### 4. 指挥属性（Command Attributes）

当兵种为指挥类兵种时，该项有效。

- **指挥能力 (`command_capability`)**：它影响部队的士气值和整个战斗群的联合火力值。
- **指挥范围 (`command_range`)**：描述包含该兵种的部队成为指挥主体时，该部队能够指挥的六角格半径范围。

#### 5. 模型与渲染属性（Rendering Attributes）

> 通过特殊组件映射而不是其属性。

- **当前显示模型 (`current_model`)**：当前显示的模型。是 Cesium 加载 gltf/glb 模型后得到的 Model 实例。
- **当前LOD级别 (`current_lod_levels`)**：`current_model`的LOD级别。
- **当前播放动画 (`current_animation`)**：当前正在播放的动画。**动画播放时LOD锁定不切换。**
- **LOD模型 (`lod`)**：所有LOD级别的模型实例和各自对应的LOD级别列表。

  - **`model`**：当前LOD级别的模型实例。
  - **`level`**：当前实例对应的LOD级别。
- **动画列表 (`animation_list`)**：模型包含的所有动画的名称、播放方式等。

### (1b) 兵种：数据结构

```json
{
  "unit_type_id": "infantry_base",
  "unit_name": "普通步兵",
  "service": ["land"],
  "category": "步兵",
  "unit_availability": ["blue", "red"],
  "combat_attributes": {
    "attack_power": {
      "base_attack_power": 100,
      "domain_factor": {
        "land": 1.0,
        "sea": 0.5,
        "air": 0.0
      },
      "terrain_factor": {
        "plain": 1.0,
        "hill": 0.9,
        "mountain": 0.8,
        "water": 0.0
      }
    },
    "defense_power": {
      "base_defense_power": 80,
      "domain_factor": {
        "land": 1.0,
        "sea": 0.6,
        "air": 0.0
      },
      "terrain_factor": {
        "plain": 1.0,
        "hill": 0.95,
        "mountain": 0.9,
        "water": 0.0
      }
    }
  },
  "survival_attributes": {
    "visibility_radius": 6,
    "action_point_post": {
      "base_action_point_cost": 10,
      "terrain_factor": {
        "plain": 1.0,
        "hill": 1.2,
        "mountain": 1.5,
        "water": 10000
      }
    },
    "recovery_rate": 0
  },
  "command_attributes": {
    "command_capability": 1.0,
    "command_range": 2
  },
  "rendering_attributes": {
    "current_model": { "id": "model_high" },
    "current_lod_level": 0,
    "current_animation": {
      "name": "walk",
      "loopMode": "REPEAT",
      "autoPlay": false,
      "speedMultiplier": 1.0
    },
    "lod": [
      {
        "level": 0,
        "model": { "id": "model_high" }
      },
      {
        "level": 1,
        "model": { "id": "model_mid" }
      },
      {
        "level": 2,
        "model": { "id": "model_low" }
      }
    ],
    "animation_list": [
      {
        "name": "walk",
        "loopMode": "REPEAT",
        "autoPlay": false,
        "speedMultiplier": 1.0
      },
      {
        "name": "attack",
        "loopMode": "CLAMP",
        "autoPlay": false,
        "speedMultiplier": 1.0
      },
      {
        "name": "die",
        "loopMode": "CLAMP",
        "autoPlay": false,
        "speedMultiplier": 1.0
      }
    ]
  }
}
```

### (2a) 部队：属性解释

部队（Force）是由一种或多种兵种组合而成的军事单位，是兵棋引擎中实际进行移动、作战的最小战术单位。每支部队的各项属性基于所含兵种的属性和其他动态参数进行计算和变化。

#### 1. 基础标识属性（Identification）

- **部队编号 (`force_id`)**：部队的唯一标识，用于数据库操作、API调用、前后端通信。
- **部队名称 (`force_name`)**：显示在界面上的部队名称，如“陆军33号部队”。
- **隶属阵营 (`faction`)**：描述部队所属阵营，每个部队只能属于一个阵营。例如：“英国”、“蓝方”。
- **军种类型 (`service`)**：描述部队整体所属军种，不同军种的兵种不能存在于同一支部队中。
- **位置编号 (`hex_id`)**：部队当前所处的六角格位置标识，用于确定其位置与相关环境因素的影响。

#### 2. 组成属性（Composition）

- **兵种引用 (`unit_id`)**：兵种的编号。
- **兵种基数 (`unit_count`)**：反映了该兵种在部队整体中所占的人数比例。

  > 兵种组成只有在特定情况下才能变动，平时保持固定，避免引擎复杂度增加。
  >

#### 3. 战斗属性（Combat Attributes）

- **兵力值 (`troop_strength`)**：部队当前的总兵力值，取值范围为 0 ~ 100，反映部队的战损状况。兵力值为 0 时，部队被判定消灭。

  > 兵力值恢复公式：`本回合兵力值 = min(100, 上回合兵力值+兵力值恢复速率)`
  >
  > 战斗时兵力值的减少见战斗裁决表。
  >
- **士气值 (`morale`)**：

  - 描述部队当前的士气状况，初始值为 100。
  - 影响部队的火力值。
  - 受兵力值和指挥能力影响，士气越低，战斗效能越差。

  > `士气值 = min(100, max(50, (100-0.5×(100-兵力值))×指挥能力))`，取值在 50~100之间。
  >
- **进攻火力值 (`attack_firepower`)**：

  - 描述部队的整体进攻能力，细分为对地、对海、对空三类。
  - 根据部队内各兵种的攻击属性与兵种基数综合计算。
  - 受当前士气值影响。

  > `对海(陆,空)攻击火力值 = ∑(兵种对海(陆,空)攻击力×兵种基数)×士气值%`
  >
- **防御火力值 (`defense_firepower`)**：

  - 描述部队的整体防御能力，同样细分为对地、对海、对空三类。
  - 根据部队内各兵种的防御属性与兵种基数综合计算。
  - 受当前士气值影响。

  > `对海(陆,空)防御火力值 = ∑(兵种对海(陆,空)防御力×兵种基数)×士气值%`
  >
- **战斗机会 (`combat_chance`)**：

  - 描述部队本回合还能主动发起战斗的次数。
  - 每回合恢复 2 点，最高为 1，初始为 0。
  - 次数降为 0 后无法主动攻击，但被攻击时仍需防御，所以会继续下降。下降至 -2 后停止变化。
- **疲劳系数 (`fatigue_factor`)**：

  - 影响兵力值恢复速率。
  - 与部队的剩余战斗次数相关，当剩余战斗次数降至 0 以下时下降，恢复到 ≥0 时重置为初始值。

  > 战斗次数为 -1 时，疲劳系数为 0.9；战斗次数为 -2 时，疲劳系数为 0.8
  >

#### 4. 生存属性（Survival Attributes）

- **可视范围 (`visibility_radius`)**：

  - 描述该部队的最大可视范围，它取决与部队中视野最大的兵种。

  > `可视范围 = max(组成兵种的可视范围)`
  >
- **行动力 (`action_points`)**：

  - 描述部队当前回合内剩余的移动能力。
  - 初始值为 100，每次移动时，根据移动经过地形中行动力消耗速率最大的兵种消耗行动力。

  > `当前格所剩行动力 = 上一格所剩行动力 - 当前格的组成兵种中最大的行动力消耗速率`
  >
  > 行动力的消耗速率是动态变化的，因为走到下一格时地形若发生变化，行动力消耗速率最大的兵种可能就是另一个了。
  >
- **兵力值恢复速率 (`recovery_rate`)**：

  - 每回合结束时部队兵力的自然恢复能力。
  - 由疲劳系数和组成兵种中的恢复能力属性共同决定。

  > `兵力值回复速率 = 疲劳系数×∑(兵种的恢复能力×兵种基数)`
  >

#### 5. 指挥属性（Command Attributes）

每个部队都**至少需要有一名**指挥官。当部队内存在多名指挥官时，以下属性取这些指挥官中**指挥能力值最高者**。

- **指挥能力 (`command_capability`)**：含义同兵种同名属性。
- **指挥范围 (`command_range`)**：含义同兵种同名属性。

### (2b) 部队：数据结构

```json
{
  "force_id": 6,
  "force_name": "陆军33号部队",
  "faction": "blue",
  "service": "land",
  "hex_id": "H0236",
  "composition": [
    {
      "unit_ref": "infantry_base",
      "unit_count": 5
    },
    {
      "unit_ref": "artillery_base",
      "unit_count": 3
    }
  ],
  "combat_attributes": {
    "troop_strength": 100,
    "morale": 100,
    "attack_firepower": {
      "land": 120,
      "sea": 10,
      "air": 0
    },
    "defense_firepower": {
      "land": 85,
      "sea": 8,
      "air": 0
    },
    "remaining_combat_times": 0,
    "fatigue_factor": 0.95
  },
  "survival_attributes": {
    "visibility_radius": 6,
    "action_points": 100,
    "recovery_rate": 19
  },
  "command_attributes": {
    "command_capability": 1.25,
    "command_range": 2
  }
}
```

### (3a) 战斗群：属性解释

战斗群（BattleGroup）是由若干个部队临时组成的战术联合体，仅在进行具体战斗时生成，用于表达多个部队之间的联合作战效果。战斗群的核心在于通过指挥主体实现多个部队间的联合指挥和火力协同，以提高战斗效能。

#### 1. 基础标识属性（Identification）

- **战斗群编号 (`battlegroup_id`)**：战斗群的唯一标识，用于前后端数据传输、裁决计算以及日志记录。
- **隶属阵营 (`faction`)**：描述战斗群所属的阵营（例如：“英国”、“蓝方”）。

  > 战斗群只能由同一阵营的部队组成。
  >

#### 2. 组成属性（Composition）

- **指挥主体 (`command_force_id`)**：
  - 战斗群中**唯一的指挥部队**，其他部队的联合行动均由该部队的指挥能力决定。
  - 指挥主体决定战斗群的指挥范围以及联合火力值的加成。
- **组成部队列表 (`force_id_list`)**：
  - 指挥主体指挥范围内的所有可参与进攻的部队（除了指挥主体）。

#### 3. 联合作战属性（Joint Combat Attributes）

- **联合攻击火力值 (`joint_attack_firepower`)**：

  - 描述战斗群整体进攻能力，分别对地、对海、对空进行计算。
  - 基于组成战斗群的各部队的进攻火力值加总，并额外受到指挥主体的指挥能力加成。

  > `联合攻击火力值 = ( ∑各部队攻击火力值 ) × 指挥主体的指挥能力`
  >
- **联合防御火力值 (`joint_defense_firepower`)**：

  - 描述战斗群整体防御能力，分别对地、对海、对空进行计算。
  - 基于组成战斗群的各部队的防御火力值加总，并额外受到指挥主体的指挥能力加成。

  > `联合防御火力值 = ( ∑各部队防御火力值 ) × 指挥主体的指挥能力`
  >

#### 4. 指挥属性（Command Attributes）

指挥部队的指挥属性。

- **指挥能力 (`command_capability`)**
- **指挥范围 (`command_range`)**

### (3b) 战斗群：组成规则

#### 作战规则

- **进攻时**：玩家选择一个本回合内仍有剩余战斗次数、且指挥范围存在己方部队与敌方部队接壤的部队作为指挥主体，指挥主体的指挥范围内选中的己方部队构成战斗群，对与战斗群接壤的敌方部队发起进攻。
- **防御时**：己方部队受到攻击时，受击部队自动变为指挥主体，指挥范围内的**所有**己方部队形成战斗群进行防御。

  > 若防御指挥主体的指挥能力大于2，则防御时指挥范围额外增加1个六角格。
  >

#### 战斗群构成约束

- 只有在进行战斗时才会生成战斗群。
- 一个战斗群只能包含同一阵营的部队。
- 战斗群内仅允许一个指挥主体，所有指挥相关属性均依赖于该主体。

### (3c) 战斗群：数据结构

```json
{
  "battlegroup_id": "BG001",
  "faction": "blue",
  "command_force": {
    "force_id": 6,
    "force_name": "陆军33号部队"
  },
  "forces_list": [
    {
      "force_id": 6,
      "force_name": "陆军33号部队"
    },
    {
      "force_id": 7,
      "force_name": "陆军34号部队"
    },
    {
      "force_id": 8,
      "force_name": "陆军35号部队"
    }
  ],
  "joint_attack_firepower": {
    "land": 275,
    "sea": 15,
    "air": 0
  },
  "joint_defense_firepower": {
    "land": 220,
    "sea": 12,
    "air": 0
  }
}
```

### (4a) 编队：属性解释

编队（Formation）是对己方多个部队进行分组管理的组织结构，不直接参与战斗，只用于方便统计、调度和界面展示。编队内的部队可能在地图上分散，但归为同一编队便于统一管理和展示。

#### 1. 基础标识属性（Identification）

- **编队编号 (`formation_id`)**： 编队的唯一标识，用于数据库操作、API调用及前后端通信。
- **编队名称 (`formation_name`)**： 显示在前端界面的编队名称，如“左翼前沿攻击群”，便于玩家快速识别。
- **隶属阵营 (`faction`)**： 描述编队所属的阵营（例如：“英国”、“蓝方”）。

  > 编队只能包含同一阵营的部队。
  >

#### 2. 组成属性（Composition）

- **组成部队列表 (`forces_list`)**：
  - 编队中所有部队的引用列表。
  - 编队不限制其中部队的位置关系，编队内的部队可以分散于地图上不同位置。

### (4b) 编队：数据结构

```json
{
  "formation_id": "F001",
  "formation_name": "左翼前沿攻击群",
  "faction": "blue",
  "forces_list": [
    {
      "force_id": 6,
      "force_name": "陆军33号部队"
    },
    {
      "force_id": 7,
      "force_name": "陆军34号部队"
    },
    {
      "force_id": 8,
      "force_name": "陆军35号部队"
    }
  ]
}
```

# 基本规则

1. **通用规则**
   - **回合制机制：** 系统按照回合顺序执行，每回合双方轮流进行操作，回合结束时执行兵力值恢复、剩余作战次数恢复等更新操作。
   - **\* 随机性因素：** 在战斗判定中引入一定随机性，保证每次计算结果存在微小波动，模拟真实作战的不确定性。
2. **移动规则**
   - **路径选择：** 部队只能沿着相邻的六角格进行移动，系统只支持手动选择路径。
   - **敌军通行判断：**
     - 如果路径上遇到敌军六角格，且该敌军处于战争迷雾状态（前端“visibleTo”标记为不可见），则允许继续前进；
     - 当路径进入一个敌军所在且处于不可见状态的六角格时，系统自动截断路径，使部队停在敌军前一格。该信息不预先告知玩家，但会反馈给前端，由前端通过“突发状况”效果模拟显示。
   - **行动力消耗：** 移动过程中，每经过一格消耗的行动力等于该部队组成兵种中最大“基础行动力消耗速率”×相应地形修正系数，移动总消耗不能超过部队当前的行动力。
3. **进攻规则**
   - **发起条件：** 部队（或战斗群指挥主体）必须具备正的“剩余战斗次数”，且在指挥范围内存在能够接触到敌军的部队。
   - **联合火力计算：**
     - 联合攻击火力 = （所有参战部队进攻火力总和）×（指挥主体的指挥能力加成）。
     - 各部队进攻火力为：兵种“基础攻击力”×“兵种基数”乘以当前“士气百分比”（例如士气100%时保持原值）。
   - **战斗判定：**
     - 如果联合攻击火力超过目标部队的联合防御火力，则判定进攻方获胜；否则防御方获胜。
     - 实际战斗中引入一定随机浮动，确保模拟结果具备不确定性。
4. **防御规则**
   - **防御主体：** 被攻击部队在防御时自动成为指挥主体，其指挥能力决定联合防御火力加成。
   - **联合防御火力计算：**
     - 联合防御火力 = （所有参战部队防御火力总和）×（指挥主体的指挥能力加成）。
   - **兵力损失：** 战斗双方根据火力比值计算损失比率，获胜方损失较少，失败方损失较多，具体损失比例可基于简单比例公式制定（例如：损失比例 = 1 -（己方火力/敌方火力），并加入随机微调）。
5. **士气与兵力恢复规则**
   - **士气调整：**
     - 士气受兵力损失影响。示例公式：士气 = min(100, max(50, (100 - 0.5 × (100 - 当前兵力)) × 指挥能力))。
     - 士气越低，部队在后续战斗中表现越差。
   - **兵力恢复：**
     - 每个回合结束时，部队兵力按照“兵力值恢复速率”进行恢复，恢复值受“疲劳系数”影响。
     - 恢复公式为：本回合兵力 = min(100, 上回合兵力 + 恢复速率 × 疲劳系数)。
6. **操作记录与状态更新**
   - **数据同步：** 每次完成移动、战斗后，系统将最新的部队位置、兵力、士气等状态更新到数据库，确保前后端数据同步。
   - **日志记录：** 所有命令操作、战斗裁决、移动校验等处理过程均生成操作日志，方便后续分析和问题追踪。
7. **规则反馈接口**
   - 后端在接收前端下达命令后，根据以上规则进行解析和判定，然后将操作结果（允许或拒绝）以及相关属性变更（例如新的兵力值、士气变化、被截断的移动路径等）封装为 JSON 数据返回前端，前端据此更新显示。

# 模块分层——前端

## A. 基础地理渲染层

**主要职责：**

- **地图加载与地形渲染**：加载影像、DEM数据，构建三维地形。
- **环境与光影效果**：配置光照、阴影、天气/时间效果等。
- **六角网格绘制**：在地图上生成规则的六角格，标注各个格子的信息等，并根据各属性渲染出相应的状态。
- **战争迷雾渲染：** 基于六角格数据和部队分布，实现实时的视野和战争迷雾计算，确定每个部队的可视范围，并更新相应六角格的可见性状态，以驱动前端的战争迷雾显示。

  > 六角格的数据结构见**数据结构**模块。
  >
  > 前端的六角格数据结构比后端多了一个**六角格标记状态 (`visualStyle`)**属性！
  >

**说明：** 这一层是整个渲染引擎的基础，所有后续的单位渲染、交互等功能都依赖于它。将六角格规范化与地图渲染放在一起，能使场景基础数据统一管理。

## B. 作战单位渲染与动画层

**主要职责：**

- **模型预处理与优化**：包括 LOD、多级纹理（Mipmap）、八叉树分块加载等处理，确保模型在不同距离下性能和效果兼顾。
- **军事单位放置**：根据六角格坐标，将部队模型放置到正确位置，只渲染可见区域内的单位。
- **动画与状态更新**：处理部队移动、进攻、受损、消失等动态效果和动画过渡。

**说明：** 这一层专注于作战实体的动态展示和状态变化，将单位的模型渲染与动画效果集中管理，可以独立调试单位表现而不影响地图渲染。

## C. 交互与信息展示层

**主要职责：**

- **HUD与控制面板**：构建用户界面（例如视角控制、复位、编队列表、详细信息栏、命令下达区、规则编辑区、战斗日志等）。
- **地图标记与交互**：在地图上绘制选中高亮状态、移动轨迹、区域框选、提示标记等。
- **用户交互逻辑**：处理鼠标、触控等事件，调整视角，下达命令，将操作转换为前后端交互请求。

**说明：** 这一层将用户操作和信息展示集中起来，与底层渲染模块形成联动。它不仅负责 UI 界面，也直接影响地图上的标记与交互反馈，因此分层清晰有助于后续功能扩展和用户体验优化。

## * D. 前端数据与状态管理层（可选）

**主要职责：**
建立一个轻量级的全局状态管理系统，统一管理前端关键数据（如地图状态、当前选中部队、六角格数据、视角状态等），以支持多模块之间的数据共享和实时更新，同时保持整体项目简单易维护。

- **数据同步接口：**提供与后端 API 的统一调用接口，负责获取并更新兵种、部队、六角格以及战斗、移动等实时动态数据。
- **全局状态管理：**利用轻量级状态管理工具（如 Pinia 或模块化 Vuex），集中管理全局数据，如：
  - 当前地图视角、缩放级别
  - 选中部队和选中六角格列表
  - UI 控制状态（如 HUD 面板显示状态、当前操作模式等）
  - 战斗裁决和移动结果的临时数据
- **模块解耦与协调：**通过全局状态管理，降低各 UI 组件、地图渲染模块之间的数据耦合，保证各模块在接收到状态变化时能自动响应，简化数据传递逻辑。

# 模块分层——后端

## E. 指令解析模块

**主要职责：** 统一接收前端和第三方 API 发送的 JSON 格式指令与查询请求，进行基本的结构、字段校验，然后根据指令类型路由到各业务模块（如移动、进攻、兵种/部队管理、查询等）。

**关键功能：** 指令格式验证、类型识别、初步数据解析、错误提示反馈、后续请求分发。

## F. 兵种与部队管理模块

**主要职责：** 统一管理所有兵种与部队的信息，负责兵种的创建、修改、删除及查询，同时处理部队的编制、合并和拆分操作。

**关键功能：**

- 提供标准化的 API 接口（RESTful），支持增删改查操作；
- 数据校验（例如兵种属性值、部队组合拆分合法性、所属阵营一致性等）；
- 事务处理与日志记录，确保部队编制变更的一致性。

## G. 战斗裁决与判定模块

**主要职责：** 根据当前作战数据与各部队的属性，实时计算交战双方的联合火力比，判断胜负，并更新部队战损和状态。

**关键功能：**

- 根据部队和战斗群数据（包含指挥主体和参战部队）进行火力合成；
- 执行简单概率模型（可适当引入随机波动）计算战斗结果；
- 更新数据库中的兵力、状态信息，同时记录详细战斗日志供后续查询。

## H. 移动控制模块

**主要职责：** 处理部队移动请求，接收前端手动选择的六角格路径，对路径连续性和合法性进行校验，包括特殊情况下（经过迷雾中敌军）的路径截断处理，然后返回最终的合法移动路径。

**关键功能：**

- 手动路径选择的连续性校验；
- 根据六角格数据（包括地形、可通行性和敌军迷雾情况）判断路径是否合法；
- 更新部队位置，同时记录移动过程日志。

## I. 数据存储与管理模块

**主要职责：** 负责整个系统静态数据（地图、DEM、兵种、战斗规则）与动态数据（部队状态、六角格实时状态、日志记录）的存储和管理，提供统一的数据访问接口。

**关键功能：**

- 设计与维护 MySQL 数据库表结构，分为固定数据和动态数据；
- 提供高效的读写接口（包括分页、条件查询）；
- 实现缓存和事务控制，确保数据一致性；
- 日志记录所有数据变更，便于调试和系统监控。

# 详细任务与实施步骤——前端

## A. 基础地理渲染层

**目标：**建立一个稳定的三维地理基础场景，包括地图、地形、光照环境以及六角网格（棋盘）生成，为后续各模块提供统一的地理数据和视觉基础。

### (1) 地图数据加载

#### 任务1.1：集成影像与地形数据

- 配置 Cesium Viewer：设置基本参数（视角、分辨率、初始位置）。
- 调用 Web Map Service（WMS）或 Web Map Tile Service（WMTS）加载影像图层。
- 加载 DEM 数据（地形图层），确保数据格式与 Cesium 兼容。

#### 任务1.2：地图坐标和投影设置

- 确保地图使用的坐标系统（如 WGS84）与六角网格生成相匹配。
- 检查地图投影效果，调整参数以减少失真。

### (2) 环境与光影效果优化

#### * 任务2.1：设置基础光照与阴影

- 优化光照和阴影效果，调试参数获得真实感效果。

#### ** 任务2.2 ：天气/时间动态效果

- 利用 Cesium 的着色器及材质扩展，实现雨、雾等动态天气效果。
- 实现昼夜交替。

### (3) 六角网格生成与标记

#### 任务3.1：生成六角网格数据

- 根据地图范围和预定的六角格大小计算出所有六角格的坐标。
- 利用 Cesium API（如 Primitive 或 Polygon）生成并渲染这些网格。

#### 任务3.2：网格属性标记

⚠️前端的六角格数据结构比后端多了一个**六角格标记状态 (`visualStyle`)**属性！

- 利用 `visualStyle`属性，为每个六角格赋予不同的颜色标记。
- 保存六角格与地图坐标的对应关系，供后续单位定位使用。

### (4) 战争迷雾渲染（重点）

**目标：**在前端利用 Cesium 和 WebGL 实现动态战争迷雾效果，根据各友军部队的实时位置、视野和天气条件，计算并渲染可见区域，使得视图中仅显示己方已探测到的区域，其他部分以迷雾覆盖。

#### 任务4.1：前端数据准备

- 通过 Cesium 加载六角网格数据及地形（DEM、地形类型、海拔等）；
- 获取并维护当前所有己方部队的实时位置、单位高度等数据（例如六角格编号、视野半径等）；
- 将这些数据缓存于前端内存，以便实时计算和更新战争迷雾。

#### 任务4.2：实时可视域计算

- 每个己方部队根据其位置及设置的最大视野半径，在前端利用 Cesium API 结合简单的射线检测（例如基于线性插值、LOS算法）计算出其“可视”六角格列表；
- 考虑天气和光照条件（如大雾时自动缩小视野范围），通过前端参数进行调整；
- 将各部队计算出的可视区域合并，得到全局范围内的己方探测到的六角格集合。

#### 任务4.3：战争迷雾状态与渲染

- 利用前端计算结果，对六角格的可见性状态进行更新（为每个六角格设置 visibleTo 标记）；
- 对于处于探测范围内的六角格，按正常方式显示，而其余六角格则采用自定义的迷雾材质（可通过 Cesium 的 Polygon 或 Primitive 加动态材质/Shader 实现渐变过渡的迷雾效果）；
- 战争迷雾图层和六角网格共同叠加在地图之上，实现即时的迷雾显示效果。

#### 任务4.4：动态实时更新和存储状态

- 建立事件监听机制：每次移动、进攻、创建部队、天气/昼夜改变后，自动重新计算视域；
- 采用前端定时器或 requestAnimationFrame 机制，确保迷雾层能够实时刷新，并向用户展示最新的可见区域；
- 尽量优化计算算法，必要时使用 WebWorker 分担计算压力，确保前端整体流畅。
- 每次移动、进攻、创建部队、天气/昼夜改变的**前后**，更新后端的六角格数据结构（尤其是 `visibleTo`属性），在后端存储六角格的可见状态，确保前后端统一，便于第三方软件查询调用。

## B. 作战单位渲染与动画层

**目标：**处理后端传来的部队数据，将各兵种3D模型经过预处理优化后放置在正确的六角格上，并实现移动、交战等动画效果。

### (1) 模型预处理与优化

#### 任务1.1：模型优化处理

- 应用 LOD（多级细节加载）：为模型预先准备不同细节层次的数据。
- 使用 Mipmap 技术降低远景纹理数据的占用。
- 利用八叉树或分块加载技术，确保只加载视野内的模型数据。

#### * 任务1.2：纹理和顶点压缩

- 对模型纹理进行合并与压缩（如利用Draco压缩顶点数据），减小数据量。

### (2) 部队模型放置

#### 任务2.1：解析后端数据

- 将后端传来的部队位置数据（六角格编号）转换为对应的六角格坐标。

#### 任务2.2：模型实例化与定位

- 调用 Cesium 的 API，将优化后的部队模型散落在六角格内的不同位置（防止模型完全重叠）。

### (3) 动画与状态更新

#### 任务3.1：实现部队移动动画

- 根据用户或后端传来的移动轨迹信息，在地图上渲染出沿线移动的动画。
- 在每个途经六角格内，根据六角格的地形，动态调整部队移动动画的速度。

#### **任务3.2：**实现交战与打击动画

- 设计不同兵种的交战动画（进攻、受损等）。
- 联合作战时，确保相邻六角格间实现相应的动画联动。

#### **任务3.3：**状态更新和战损显示

- 在放置部队，交战结束，或者移动结束后，根据战损结果更新模型状态（如兵力减少、模型逐渐淡出）。
- 根据六角格的 `visibleTo`属性，对己方可见的六角格内的部队将显示，否则不显示。
- 动态刷新显示效果，确保画面与后端状态一致。

## C. 交互与信息展示层

**目标：**构建前端交互界面，包括 HUD、按钮、面板等组件，实现**视角控制、部队选中与信息展示、命令下达、地图交互**等操作。并在地图上绘制**路径轨迹、六角格高亮等交互性图层**。

**该模块是用户与前端交互的核心，也是规则系统需要对接的重要部分！**

### (1) HUD 与控制面板搭建

#### 任务 1.1：构建基础 UI 界面

使用 `Vue.js + Element UI` 搭建整体布局，划分以下交互区域：

##### (1) 视角控制区

提供以下摄像机操作按钮

- 视角居中（显示全战场）
- 视角定位到选中六角格放大
- 图层可视切换（正常图层、地形图层、隐藏六角格）

##### (2) 编队列表

以编队为分类单位列出己方所有部队。新创建的未归类部队默认分到”未分类“编队中。

- 编队项可展开，显示其下的所有部队。
- 点击**编队名称**：地图定位并高亮该编队内的所有部队所在的六角格，**不可直接下命令，仅供全览**。
- 点击**部队名称**：地图定位并高亮该支部队所在六角格，并在六角格信息栏中勾选该支部队，**可进行命令操作**。

> 在点击编队名称时，利用 `forcesList` 内的每个部队的 `hexId` 通过查询六角格数据结构来实现地图定位和高亮。

##### (3) 六角格信息栏

选中某个六角格后，展示其属性信息，包括但不限于：

- 六角格高度、地形、是否可见
- 六角格内的部队列表（发起进攻/防御/部队拆分/合并命令时可以在这里选择相关部队）

##### (4) 部队详细信息栏

选中某个部队后，展示其属性信息，包括但不限于：

- 基础信息（名称、位置、阵营等）
- 兵种组成与基数
- 当前兵力、士气、行动力、战斗属性（攻防火力）等

##### (5) 命令下达区

显示以下命令按钮：

- 移动命令（当六角格信息栏中选中部队数量为 1 时激活）
- 进攻命令（当六角格信息栏中选中部队数量为 1 时激活）
- 部队创建/拆分/合并命令
  - 选中单个中立六角格时，部队创建按钮激活
  - 选中单个六角格，并在六角格信息栏中选中多支部队时，部队合并按钮激活
  - 选中单个六角格，并在六角格信息栏中选中单支部队时，部队拆分按钮激活
- 所有命令需被封装为规则格式（JSON），传给后端规则模块进行判断。

##### (6) 战斗群列表

- 战斗发生时激活，显示当前交战的双方战斗群中所有部队的列表。
- 战斗结束后，展示每个部队本次所受到的兵力损失。

##### (7) 统计列表

统计列表中有一个统计按钮，点击统计按钮后，可在地图进行框选操作，然后在统计列表中显示被选中区域内己方和敌方的统计信息：

- 部队总数
- 总兵力值

##### (8) 部队管理面板（默认隐藏）

在收到部队创建、合并、拆分命令时弹出，分别为三个子页面，具有如下功能：

- 创建：在当前阵营可用兵种中选择兵种，按一定比例组成部队
- 合并：显示合并前的部队和合并后的部队属性预览，为新部队命名，确认后合并部队
- 拆分：显示组成部队的所有兵种类型和其对应兵种基数，通过加减调整将其分为两个或以上的部队，显示拆分后的部队属性预览，为每个新部队命名，确认后拆分部队

##### (9) 兵种管理面板（默认隐藏）

点击一个“兵种管理”按钮时弹出，具有如下功能：

- 显示当前阵营所有可用兵种
- 创建新兵种，修改、删除已有兵种

##### * (10) 战斗日志面板（可折叠）（先不写，忽略）

记录以下动态事件：

- 单位生成/移动/合并/被歼灭等
- 时间流逝/天气变化
- 战斗及规则影响结果

#### 任务 1.2：绑定 UI 交互逻辑

各按钮需绑定对应地图或后端事件：

- 摄像机操作按钮绑定 Cesium API
- 单位点击触发定位、高亮并调取详细信息
- 命令按钮与规则模块的 API 对接
- 列表项与地图图层联动交互逻辑

### (2) 地图标记与交互命令

#### 任务 2.1：视角调整

- 缩放、旋转、镜头控制、定位到任一位置等，并限定视角控制的范围（最多到地图边缘）。

#### 任务 2.2：选中状态与高亮显示

- 选中的一个或多个六角格将在地图中高亮；选择**同一六角格**的多个部队（攻击、统计等命令）时，六角格信息栏会打上相应的勾；选择**不同六角格**的多个部队（只有统计命令）时，六角格信息栏不显示，只在统计列表中显示相关部队信息。
- 正常浏览状态下，六角格及部队的选中，只有两种方式：

  1. **用户在地图上通过点击，只能实现选中单个六角格的单个部队。**点击六角格可以选中该六角格；六角格信息栏中默认没有部队被选中。
  2. **用户通过与 HUD 界面的六角格信息栏交互，可以实现选中单个六角格的多个部队。**
  3. **用户通过与 HUD 界面交互，可以实现多选六角格。**通过框选统计和进攻可以选中多个六角格；通过移动命令可以选中多个空白六角格。
- 该模块维护一个核心数据结构：`selected_hex_list`

  - 用于追踪当前被用户选中的六角格
  - 被选中的六角格将在地图上高亮显示
- 该模块维护一个核心数据结构：`selected_forces_list`

  - 用于追踪当前被用户选中的部队
  - 在非进攻模式下，`selected_hex_list` 发生变化后，`selected_forces_list` 清空
  - 在进攻模式下，由于需要逐步选中多个六角格的部队，所以 `selected_hex_list` 发生变化时，`selected_hex_list` 不清空，退出进攻模式后自动清空

#### 任务 2.3：区域框选与统计

1. 支持鼠标拖拽绘制矩形框，框选地图上的六角格。
2. 实时统计：

   - 框选范围内部队数量与兵力总量
   - 编队分布情况
3. 将框选到的六角格列表发送给后端，后端返回这些六角格内的双方部队信息
4. 统计列表内分两块区域显示己方和敌方的部队信息

#### 任务 2.4：命令——部队移动交互

步骤流程如下：

1. 选中单个部队 → 点击“移动”按钮 → 进入移动模式
2. 用户点击地图路径上的六角格，生成路径列表，系统将依次执行以下步骤：

   1. 检测该六角格是否已点击过，点击过则忽略
   2. 检测该六角格是否与上一格六角格相接，不相接则忽略
   3. 初步检测该地形是否为不可通行区域（如悬崖、陆军过海）
      - 若可通行，则高亮该格，并加入 `selected_hex_path_list`
      - 若不可通行，则提示错误并忽略点击
3. 用户点击“确认路径” → 将路径信息发送至后端进行**进一步合法性检测**：

   - **先更新后端的六角格信息（主要是 `visibleTo`属性），便于后端判断是否会突然遇敌**
   - 然后将路径发送给后端校验

   > 一般来说，如果前后端一致的话，就只会有遇敌情况了，后端校验合法性一般都能通过。
   >
4. 后端返回两种情况：

   - **可行**：
     1. 后端返回最终路径（因为可能会遇敌，偷偷改成被截断后的路径给前端渲染），同时修改相关的数据结构为行走完成的状态
     2. 更新单位位置，渲染移动动画，并用路径线展示轨迹；将走过的六角格的“隶属方”属性改为己方
   - **不可行**：
     1. 后端返回提供因行动力不足，能走到的最远位置，提示用户是否执行部分路径
     2. 用户需要选择执行或者不执行：
        - 执行：后端修改相关的数据结构为行走完成的状态
        - 不执行：后端放弃更改

#### 任务 2.5：命令——部队进攻交互

步骤流程如下：

1. 选中六角格后，**在六角格信息栏中**选中单个部队 → 点击“进攻”按钮 → 进入进攻模式，选中的部队作为指挥主体被勾选。
2. 可以进攻的敌方六角格需满足以下两个条件：

   - 与指挥范围相接壤（或包含在范围内）的敌军六角格
   - 与敌军六角格接壤的部队中至少有一支能够战斗（剩余战斗次数大于 0）
3. 六角格信息栏中，可参战部队可勾选，不可参战部队为灰色不可勾选。可参战部队需满足以下两个条件：

   - 指挥主体默认被勾选，不可取消勾选
   - 位于指挥主体的指挥范围内
   - 剩余战斗次数大于 0
4. 用户点击执行后，前端会判断：

   - 与目标六角格相接壤的我军六角格内至少有一支部队参与战斗
5. 若满足条件，构建战斗群数据结构并提交给后端：

   - 后端进行与上面相同的合理性校验（确保前后端一致）
   - 后端计算战斗裁决并返回战斗结果
   - 前端渲染战斗动画与打击效果（如爆炸、射击动画等）
   - 在“战斗群列表”面板中展示双方参战单位及损失情况

#### 任务 2.6：命令——部队创建交互

步骤流程如下：

1. 选中单个六角格 → 点击“创建”按钮 → 进入部队创建模式
2. 显示部队管理面板的创建页面，界面设计可对接该模块的 `(1) HUD 与控制面板搭建——部队管理面板`

#### 任务 2.7：命令——部队合并交互

步骤流程如下：

1. 选中单个六角格 → 点击“合并”按钮 → 进入部队创建模式
2. 显示部队管理面板的创建页面，界面设计可对接该模块的 `(1) HUD 与控制面板搭建——部队管理面板`

#### 任务 2.8：命令——部队拆分交互

步骤流程如下：

1. 选中单个六角格 → 点击“拆分”按钮 → 进入部队拆分模式
2. 显示部队管理面板的拆分页面，界面设计可对接该模块的 `(1) HUD 与控制面板搭建——部队管理面板`

#### 任务 2.9：命令——兵种管理交互

步骤流程如下：

1. 进入兵种管理模式
2. 显示兵种管理面板，界面设计可对接该模块的 `(1) HUD 与控制面板搭建——部队管理面板`

## (3) 指令格式

后端规则模块接收到前端发送的命令 JSON 后，会根据命令类型调用对应校验规则，确保各项条件满足，然后交由相关模块执行（如移动模块、战斗模块或部队管理模块）。

**每条指令都封装为一个标准 JSON 对象，其中须包含以下核心字段：**

- **command_type**：指令类型，取值包括 "MOVE"、"ATTACK"、"CREATE_FORCE"、"MERGE_FORCES"、"SPLIT_FORCE" 等。
- **timestamp**：指令下达时间，用于后续时序校验（可选）。
- **source/force 信息**：针对移动、进攻或拆分等命令，记录发起者的部队编号或引用。
- **目标信息**：根据命令不同可能为目标六角格、目标部队、或其它相关数据。
- **附加参数**：如路径、预估消耗、拆分详情、等扩展数据。

下面提供几个常见命令类型的示例：

### 1. 命令类指令

#### 1.1 移动命令（MOVE）

```json
{
  "command_type": "MOVE",
  "force_id": 103,                     // 发起移动的部队编号
  "path": [2450, 2449, 2452, 2468],     // 六角格编号
  "timestamp": "2025-04-08T12:00:00Z",
  "parameters": {
    "estimated_action_points_cost": 35  // 初步计算的行动力消耗
  }
}
```

#### 1.2 进攻命令（ATTACK）

```json
{
  "command_type": "ATTACK",
  "command_force_id": 103,         // 选中的指挥主体部队编号（必须在指挥范围内）
  "target_hex": 4567,              // 敌方目标所在六角格编号
  "support_force_ids": [104, 105],  // 其他参战部队的编号（指挥范围内的友军部队）
  "timestamp": "2025-04-08T12:05:00Z",
  "parameters": {
    "expected_firepower": {
      "attack": {"land": 300, "sea": 20, "air": 10},
      "defense": {"land": 200, "sea": 15, "air": 5}
    }
  }
}
```

*说明*：后端规则模块会检查：

- 指挥主体是否在进攻前拥有足够的剩余战斗次数，
- 指挥主体的指挥范围内是否有与目标六角格相接壤的己方部队，
- 目标六角格是否确实为敌方所占，
- 然后根据联合火力和其他战术参数计算战斗结果。

#### 1.3 部队创建命令（CREATE_FORCE）

```json
{
  "command_type": "CREATE_FORCE",
  "hex_id": 789,                   // 选中创建部队的中立六角格编号
  "faction": "blue",               // 将创建的部队所属阵营
  "composition": [                 // 选择的兵种构成与各自兵种基数
    {
      "unit_type_id": "infantry_base",
      "unit_count": 3
    },
    {
      "unit_type_id": "artillery_base",
      "unit_count": 2
    }
  ],
  "timestamp": "2025-04-08T12:10:00Z"
}
```

*说明*：规则模块将检测所选六角格是否处于中立状态，并确认阵营和兵种匹配条件，继而调用创建逻辑。

#### 1.4 部队合并命令（MERGE_FORCES）

```json
{
  "command_type": "MERGE_FORCES",
  "hex_id": 789,                   // 待合并部队所处六角格编号
  "force_ids": [123, 124, 125],      // 待合并的各部队编号
  "timestamp": "2025-04-08T12:15:00Z"
}
```

*说明*：规则模块需验证所有部队是否处于同一六角格且同一阵营，以及兵力值、行动力等状态类值必须为满时才可拆分，若满足则合并并更新组合后的属性值。

#### 1.5 部队拆分命令（SPLIT_FORCE）

```json
{
  "command_type": "SPLIT_FORCE",
  "force_id": 123,                    // 待拆分部队编号
  "split_details": [                  // 拆分信息：按照兵种基数分割成不同新部队
    {
      "unit_type_id": "infantry_base",
      "unit_count": 2,
      "new_force_name": "Alpha Squad"
    },
    {
      "unit_type_id": "infantry_base",
      "unit_count": 3,
      "new_force_name": "Bravo Squad"
    }
  ],
  "timestamp": "2025-04-08T12:20:00Z"
}
```

*说明*：规则模块需要校验拆分比例是否合理，以及兵力值、行动力等状态类值必须为满时才可拆分，并更新拆分后各新部队的属性、兵力和行动力等状态。

#### 1.6 兵种创建命令（CREATE_UNIT_TYPE）

创建命令包含完整的兵种属性设置，允许自定义各项属性。

```json
{
  "command_type": "CREATE_UNIT_TYPE",
  "timestamp": "2025-04-08T12:30:00Z",
  "unit_data": {
    "unit_type_id": "tank_heavy_01",
    "unit_name": "重型坦克",
    "service": ["land"],
    "category": "armor",
    "unit_availability": ["blue"],
    "combat_attributes": {
      "attack_power": {
        "base_attack_power": 150,
        "domain_factor": {
          "land": 1.0,
          "sea": 0.0,
          "air": 0.8
        },
        "terrain_factor": {
          "plain": 1.0,
          "mountain": 0.7,
          "urban": 1.1,
          "water": 0.0,
          "forest": 0.9,
          "desert": 1.0
        }
      },
      "defense_power": {
        "base_defense_power": 130,
        "domain_factor": {
          "land": 1.0,
          "sea": 0.0,
          "air": 0.5
        },
        "terrain_factor": {
          "plain": 1.0,
          "mountain": 0.9,
          "urban": 1.0,
          "water": 0.0,
          "forest": 0.8,
          "desert": 1.0
        }
      }
    },
    "survival_attributes": {
      "visibility_radius": 4,
      "action_point_post": {
        "base_action_point_cost": 15,
        "terrain_factor": {
          "plain": 1.0,
          "mountain": 1.3,
          "urban": 1.0,
          "water": 10000,
          "forest": 1.2,
          "desert": 1.0
        }
      },
      "recovery_rate": 0
    },
    "command_attributes": {
      "command_capability": 0,
      "command_range": 0
    },
    "rendering_attributes": {
      "model_path": "models/tank_heavy.glb",
      "lod_levels": [
        {
          "level": 0,
          "distance": 0,
          "model_path": "models/tank_heavy_high.glb"
        },
        {
          "level": 1,
          "distance": 800,
          "model_path": "models/tank_heavy_mid.glb"
        },
        {
          "level": 2,
          "distance": 2000,
          "model_path": "models/tank_heavy_low.glb"
        }
      ],
      "animation_list": [
        {
          "animation_name": "move",
          "file_path": "animations/tank_move.glb"
        },
        {
          "animation_name": "attack",
          "file_path": "animations/tank_attack.glb"
        },
        {
          "animation_name": "hit",
          "file_path": "animations/tank_hit.glb"
        },
        {
          "animation_name": "destroy",
          "file_path": "animations/tank_destroy.glb"
        }
      ]
    }
  }
}
```

#### 1.7 兵种修改命令（MODIFY_UNIT_TYPE）

修改命令用于更新已有兵种的部分属性，这里只修改兵种名称、进攻和防御的基础数值以及模型资源路径作为示例。

```json
{
  "command_type": "MODIFY_UNIT_TYPE",
  "timestamp": "2025-04-08T12:35:00Z",
  "unit_type_id": "tank_heavy_01",
  "modified_fields": {
    "unit_name": "重型坦克 MkII",
    "combat_attributes": {
      "attack_power": {
        "base_attack_power": 160
      },
      "defense_power": {
        "base_defense_power": 135
      }
    },
    "rendering_attributes": {
      "model_path": "models/tank_heavy_mk2.glb"
    }
  }
}
```

#### 1.8 兵种删除命令（DELETE_UNIT_TYPE）

删除命令只需传递待删除兵种的唯一标识。

```json
{
  "command_type": "DELETE_UNIT_TYPE",
  "timestamp": "2025-04-08T12:40:00Z",
  "unit_type_id": "tank_heavy_01"
}
```

### 2. 查询类指令

**这些查询接口提供了从局部到全局的各类战场信息查询，既方便前端实时展示，也满足第三方决策软件获取战场状态、部署、分布和统计信息的需求，帮助系统下达更合理、精准的命令。**

以下给出可能的查询类指令，仅供参考，不一定每一个都要实现，也不一定只实现提到的指令。

#### 2.1 查询单个六角格信息

根据唯一的六角格编号获取详细属性数据，返回的位置数据采用 Cesium 坐标格式（经纬度＋高度）。

```json
{
  "query_type": "GET_HEX_TILE",
  "parameters": {
    "hex_id": "H0001"
  }
}
```

#### 2.2 查询指定区域内的所有六角格

根据经纬度边界或逻辑行列号范围查询区域内所有六角格信息，便于决策系统了解区域地形和阵地分布。

```json
{
  "query_type": "GET_HEX_TILES_IN_AREA",
  "parameters": {
    "min_longitude": 116.0,
    "max_longitude": 117.0,
    "min_latitude": 39.0,
    "max_latitude": 40.0
  }
}
```

或者采用逻辑行列号范围：

```json
{
  "query_type": "GET_HEX_TILES_IN_AREA",
  "parameters": {
    "min_row": 8,
    "max_row": 12,
    "min_col": 4,
    "max_col": 7
  }
}
```

#### 2.3 查询指定六角格内的所有部队信息

获取某个六角格内驻扎或经过的部队列表，有助于判断该区域的战场态势。

```json
{
  "query_type": "GET_FORCES_BY_HEXTILE",
  "parameters": {
    "hex_id": "H0001"
  }
}
```

#### 2.4 查询兵种列表

返回系统中所有可用兵种的信息，包含各兵种的基础属性、战斗属性、指挥属性和渲染属性，用于决策系统参考兵种构成。

```json
{
  "query_type": "GET_UNIT_TYPES",
  "parameters": {
    "faction": "blue"  // 可选，若传入则返回该阵营可用的兵种
  }
}
```

#### 2.5 查询单个部队详细信息

根据部队编号查询部队的全部属性数据，包括位置、兵种组成、当前战斗属性、生存状态和指挥属性等。

```json
{
  "query_type": "GET_FORCE_DETAILS",
  "parameters": {
    "force_id": 6
  }
}
```

#### 2.6 查询指定区域或阵营内所有部队信息

用于获取当前战场部署，决策系统可根据区域、阵营或其他条件筛选部队。

```json
{
  "query_type": "GET_FORCES_BY_FILTER",
  "parameters": {
    "faction": "blue",
    "area": {
      "min_longitude": 116.0,
      "max_longitude": 117.0,
      "min_latitude": 39.0,
      "max_latitude": 40.0
    }
  }
}
```

#### 2.7 查询编队列表

返回指定阵营下所有编队的简要信息，用于前端显示编队列表和第三方决策软件获取部队编队分布情况。

```json
{
  "query_type": "GET_FORMATIONS_BY_FACTION",
  "parameters": {
    "faction": "blue"
  }
}
```

#### 2.8 查询单个编队详细信息

根据编队编号返回该编队包含的所有部队信息以及其他基本属性。

```json
{
  "query_type": "GET_FORMATION_DETAILS",
  "parameters": {
    "formation_id": "F001"
  }
}
```

#### 2.9 查询战斗群列表

返回当前交战中（或最近一场战斗中生成的）的所有战斗群简要信息，便于决策系统了解当前战场联合作战状态。

```json
{
  "query_type": "GET_BATTLEGROUPS_BY_FACTION",
  "parameters": {
    "faction": "blue"
  }
}
```

#### 2.10 查询单个战斗群详细信息

根据战斗群隶属阵营获取详细数据，包括指挥主体、组成部队及联合火力值。

```json
{
  "query_type": "GET_BATTLEGROUP_DETAILS",
  "parameters": {
    "faction": "blue"
  }
}
```

#### 2.11 查询全局战场统计数据

决策系统自动分析当前战场总览信息，如各阵营部队总数、总兵力、区域控制情况等统计数据。

```json
{
  "query_type": "GET_BATTLEFIELD_STATISTICS",
  "parameters": {
    "region": {
      "min_longitude": 115.0,
      "max_longitude": 118.0,
      "min_latitude": 38.0,
      "max_latitude": 41.0
    }
  }
}
```

#### 2.12 根据控制权查询六角格列表

返回某一阵营控制下的所有六角格信息，帮助判断阵地分布和占领状态。

```json
{
  "query_type": "GET_HEXTILES_BY_CONTROL",
  "parameters": {
    "control_faction": "blue"
  }
}
```

#### 2.13 查询特定兵种在部队中的分布情况

返回指定兵种在给定区域（或阵营）内出现的部队分布，便于决策软件进行兵种搭配分析。

```json
{
  "query_type": "GET_FORCE_DISTRIBUTION_BY_UNIT_TYPE",
  "parameters": {
    "unit_type_id": "infantry_base",
    "faction": "blue"
  }
}
```

## * D. 前端数据与状态管理层（可选）

**选型与框架集成：**

- 选择轻量级状态管理工具（推荐 Pinia，代码简单且与 Vue3 兼容，或采用模块化 Vuex 方案）。
- 在项目中配置全局状态管理，确保各组件可以方便地读取和更新状态。

**数据同步接口设计：**

- 封装与后端的 API 调用模块，实现数据的统一获取和更新（例如部队、兵种、六角格数据等）；
- 实现数据缓存机制，避免频繁请求造成性能问题。

**全局状态管理：**

- 定义全局状态数据结构，如：

  ```json
  {
    "mapState": {
      "viewMode": "3D",
      "center": { "longitude": 116.407394, "latitude": 39.904211, "height": 50 }
    },
    "selectedHexList": [],
    "selectedForceList": [],
    "unitData": [],
    "forceData": [],
    "battleResult": null
  }
  ```
- 对重要状态进行模块化分离，例如分“地图状态”、“选中状态”、“业务数据状态”等子模块。
- 建立状态更新函数和相应的事件监听器，确保当数据更新后，相关组件能够自动刷新显示。

**事件绑定与组件通信：**

- 在各功能组件（如 HUD、部队列表、地图标记组件等）中接入全局状态管理，确保用户操作后，状态变化可以自动传递到其他组件。
- 例如，当用户点击某部队时，更新 `selectedForceList`，同时地图高亮组件监听该状态变化进行实时更新。

**调试与文档：**

- 编写简单的状态管理使用说明，记录各全局状态数据的作用和更新流程；
- 在开发过程中利用调试工具（如 Vue DevTools 或 Pinia 调试插件）监控全局状态，确保状态管理正确稳定。

# 详细任务与实施步骤——后端

## E. 指令解析模块（次重点）

### 1. 设计思路

**主要思路**

- **统一入口**：所有 JSON 指令和查询请求都通过指令解析模块（Command Parsing Module，简称 CPM）进入后端。模块首先依据指令中的 `command_type` 字段确定请求类型。
- **模块分发**：根据不同的 `command_type`，CPM 将命指令令分发给不同的处理模块。例如：
  - `MOVE` → 移动控制模块
  - `ATTACK` → 战斗裁决与判定模块
  - `MODIFY_UNIT`、`CREATE_FORCE`、`MERGE_FORCE`、`SPLIT_FORCE` → 兵种与部队管理模块
  - 查询相关指令（如 `GET_UNIT_STATUS`、`GET_FORCE_STATUS`、`GET_HEX_INFO`、`GET_FORMATION_LIST`、`GET_BATTLEGROUP_STATUS`、`GET_MAP_STATE` 等）→ 查询类指令处理
- **规则校验与反馈**：在指令分发前，CPM 对指令进行初步校验（如基本字段是否齐全，数据格式是否正确等），并调用规则模块检查指令是否符合预设条件。校验通过后，CPM 将指令数据传给对应处理模块，最终将执行结果或错误信息以统一 JSON 格式返回给调用方。

**接口统一格式**

- 返回格式统一为：

  ```json
  {
    "status": "success",  // 或 "error"
    "data": { ... },
    "message": ""
  }
  ```
- 所有传输的 JSON 指令和查询均遵循统一规范，便于后续扩展和维护。

### 2. 功能模块划分

该模块主要包括以下子模块：

- **指令解析器**：负责接收来自前端和第三方 API 的 JSON 数据，对指令字段进行解析，检验指令格式和必要字段是否存在。
- **规则校验器**：根据当前兵棋引擎规则库，对提交的指令进行合法性验证，如移动路径连续性、进攻条件、部队状态检查等。如果校验不通过，则及时返回错误提示。
- **模块分发器**：根据指令类型（`command_type` 字段），将指令分发到相应的子模块：
  - **移动控制模块**：处理部队移动指令。
  - **战斗裁决与判定模块**：处理进攻指令，并计算联合火力、战斗结果等。
  - **兵种与部队管理模块**：处理部队创建、拆分、合并等指令。
  - **多个与这些查询指令相关的模块**：接收并响应各类状态和数据查询请求。
- **日志记录与反馈模块**：对所有指令请求、规则校验、处理结果进行日志记录，并将反馈结果统一返回前端和第三方 API。

### 3. 工作流程

1. **接收与解析**
   - CPM 接收到 JSON 格式的请求后，先进行基本格式解析，确认 `command_type`、`timestamp` 等字段是否存在。
   - 若发现异常，立即返回错误信息。
2. **规则校验**
   - CPM 调用规则校验器，根据 `command_type` 调用对应规则，如：
     - 对于 `"MOVE"` 命令，检测路径连续性、部队当前行动力、目标六角格可通行性等。
     - 对于 `"ATTACK"` 命令，检查指挥主体的剩余战斗次数、是否在指挥范围内等。
   - 若规则检查不通过，则返回错误提示信息（如“行动力不足”、“路径不连续”等）。
3. **模块分发**
   - 若规则校验通过，CPM 根据 `command_type` 将命令数据转发至对应功能模块。
   - 功能模块接收命令后，根据内部逻辑进行状态更新、计算或数据查询。
4. **处理结果反馈**
   - 功能模块处理完后将结果数据返回至 CPM。
   - CPM 统一包装为标准返回格式，再将结果传回给调用者（前端或第三方 API）。
   - 同时生成相应日志记录，便于后续审计和调试。

### 4. 查询类型示例

- 查询单个兵种状态：

  ```json
  {
    "command_type": "GET_UNIT_STATUS",
    "unit_type_id": "infantry_base",
    "timestamp": "2025-04-08T12:30:00Z"
  }
  ```
- 查询单个部队状态：

  ```json
  {
    "command_type": "GET_FORCE_STATUS",
    "force_id": 103,
    "timestamp": "2025-04-08T12:31:00Z"
  }
  ```
- 查询单个六角格信息：

  ```json
  {
    "command_type": "GET_HEX_INFO",
    "hex_id": "H0001",
    "timestamp": "2025-04-08T12:32:00Z"
  }
  ```
- 查询编队列表：

  ```json
  {
    "command_type": "GET_FORMATION_LIST",
    "faction": "blue",
    "timestamp": "2025-04-08T12:33:00Z"
  }
  ```
- 查询战斗群信息：

  ```json
  {
    "command_type": "GET_BATTLEGROUP_STATUS",
    "battlegroup_id": "BG001",
    "timestamp": "2025-04-08T12:34:00Z"
  }
  ```
- 查询地图整体状态（例如战争迷雾状态、当前图层显示等）：

  ```json
  {
    "command_type": "GET_MAP_STATE",
    "filter": {
      "visible_to": "blue"
    },
    "timestamp": "2025-04-08T12:35:00Z"
  }
  ```

## F. 兵种与部队管理模块

建立和维护所有兵种及部队编制数据，提供简单的创建、修改、删除和查询接口，为后续作战裁决和规则判断提供基础数据。

### 1. 接口设计

- 为兵种提供 REST API 接口，支持：
  - 查询所有兵种及单个兵种信息
  - 新增、修改、删除兵种
- 为部队提供 REST API 接口，支持：
  - 查询所有部队以及单个部队详情
  - 创建部队（由多个兵种编号及其基数组合）
  - 部队合并和拆分操作（合并同一区域、同一阵营的部队；拆分后生成新部队）

### 2. 数据校验

- 对兵种数据：检查基础属性（兵种ID、名称、军种、类别、可用阵营）是否完整，数值（如攻击、防御、移动消耗等）是否在合理范围内。
- 对部队数据：确认输入的兵种引用与兵种管理一致，兵种基数为正整数，且部队所属阵营和所在位置（六角格编号）正确，部队的

### 3. 业务逻辑处理

- **兵种管理**：
  - 当用户新增或修改兵种时，系统直接保存并更新数据库记录。
  - 删除兵种前，检查是否有部队引用该兵种，若有则提示不能删除或要求先进行调整。
- **部队管理**：
  - 新建部队时，根据输入的兵种组合计算初始兵力、火力、士气等数值；将部队信息存入数据库，并关联当前所在六角格。
  - 合并操作：选择同一六角格内同一阵营的多个部队，合并后更新兵力、士气、火力等属性，删除原记录；
  - 拆分操作：根据用户指定的拆分比例，将某部队拆分为两个或多个新部队，并计算各自属性后保存，新部队默认位于原位置或提示用户输入新位置。

## G. 战斗裁决与判定模块

**任务目标：**

实时判断交战双方的战斗结果，计算各部队的进攻、防御数据和兵力损失，并更新部队状态，最终将结果反馈给前端显示。

### 1. 接口设计与数据接收

- 设计一个 REST API 接口，接收前端的战斗请求。
- 请求数据采用标准的 JSON 格式，包含指挥主体、支援部队、目标六角格等信息。

### 2. 战斗群生成

- 根据前端提供的信息，生成交战双方的战斗群数据。
- 确定进攻方的指挥主体（及其指挥能力）和其指挥范围内参战的其他部队，组建完整的作战群。

### 3. 战斗结果计算

- 根据每个部队的进攻火力、防御火力、士气和兵力数值计算联合火力。
- 公式示例：
  - 联合攻击火力 =（各部队进攻火力之和）×（指挥主体的指挥能力）
  - 联合防御火力 =（各部队防御火力之和）×（指挥主体的指挥能力）
- 引入简单的随机数机制，为战斗结果增加不确定性（例如设定一定的浮动范围）。

### 4. 结果判定与状态更新

- 根据双方火力比值，判断哪一方获胜，并计算各部队损失的兵力。
- 若获胜部队，其兵力按一定比例减少对方兵力；失败方的兵力大幅下降。
- 更新数据库中对应部队的状态（如兵力数、士气下降、部队状态更新为“交战中”或“被歼灭”等）。

## H. 移动控制模块

处理部队移动请求，根据用户逐格选择的路径进行校验，判断是否满足可通行条件，并对特殊情况（如经过处于迷雾中的敌军）做出处理，最终反馈给前端显示移动轨迹和动画效果。

### 1. 路径选择

- 用户通过界面手动逐格选择六角格构成移动路径，生成一个由六角格编号构成的路径列表。

### 2. 路径校验

对选定路径进行校验：

- 检查是否有重复的六角格；
- 检查每两个相邻六角格是否相连，确保路径连续；
- 检查每个途经六角格的可通行性（如地形条件、是否被明确敌占等）；
- ⚠️检查遇敌特殊情况：
  - 当路径中存在敌军所在的六角格时，如果该敌军处于战争迷雾状态（前端六角格数据中“visible_to”标记为不可见的敌方状态），则允许部队继续通过；
  - 一旦遇到敌军且该敌军在可见范围内，则路径必须在此格前终止（即停止于敌军前一格），但该信息不提前告知用户，而是由后端在校验后返回给前端进行处理，模拟一种突发情况。

### 3. 接口设计

- 设计 REST API 接口，接收移动请求，参数包括部队编号、起始六角格和用户手动选定的路径列表；
- 返回数据包含**最终合法路径（若因敌军可见性等条件提前截断，则返回截断后的路径）**、本次移动消耗的行动力和相应错误或提示信息。

### 4. 状态更新与日志记录

- 在**路径校验通过且前端确认执行**后，将部队的新位置更新到数据库中；
- \* 记录详细操作日志，包括用户选定的原始路径、校验中遇到的特殊情况以及最终确定的路径，便于后续调试。

## I. 数据存储与管理模块

负责存储和管理所有静态与动态数据，保证各模块数据一致、实时更新，并通过提供统一的接口支持前后端数据交互。

### 1. 数据库设计与建表

- 设计 MySQL 数据库表，用于存储各类数据，如地图数据、六角格数据、兵种信息、部队编制、战斗规则、动态战局状态和日志记录。
- 为各表建立必要的索引，保证查询速度；静态数据表（如兵种模型、地图、规则）与动态数据表（如当前部队状态、六角格状态、战斗日志）分开设计以便于维护与扩展。

### 2. 固定数据管理

- 存储和管理基础地理数据（地图影像、DEM数据、六角格数据）与兵种、战斗规则等固定信息。
- 提供稳定的查询接口，供前端和其他后端模块调用，确保静态数据能够被实时加载。

### 3. 动态数据管理

- 存储当前战局的实时数据，包括：
  - 各六角格的状态（如可见性、控制方、部队分布等）
  - 各部队的当前状态（如兵力、士气、位置、剩余行动力）
  - 战斗过程中的战斗日志和动态记录
- 设计数据更新机制，支持高并发读写操作和实时数据刷新，确保战场状态随操作变化能及时同步。

### * 4. 接口与数据同步

- 提供 RESTful API 接口，使其他模块能够对数据进行快速查询和更新。例如，部队状态更新、六角格属性修改、战斗日志记录等均通过统一 API 调用实现。
- 支持数据批量写入和事务控制，保证数据一致性。

### * 5. 调试与性能优化

- 定期记录数据操作日志，便于追踪问题和调试。
- 根据数据访问频率进行缓存设计（如 Redis 缓存热数据），提高访问效率，减少数据库压力。
